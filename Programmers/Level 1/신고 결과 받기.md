#### Date : 2023-01-19  11:42

<br/>

### 문제 : 신고 결과 받기(2022 KAKAO BLIND RECRUITMENT)
---
### 문제 설명
신입사원 무지는 게시판 불량 이용자를 신고하고 처리 결과를 메일로 발송하는 시스템을 개발하려 합니다. 무지가 개발하려는 시스템은 다음과 같습니다.

-   각 유저는 한 번에 한 명의 유저를 신고할 수 있습니다.
    -   신고 횟수에 제한은 없습니다. 서로 다른 유저를 계속해서 신고할 수 있습니다.
    -   한 유저를 여러 번 신고할 수도 있지만, 동일한 유저에 대한 신고 횟수는 1회로 처리됩니다.
-   k번 이상 신고된 유저는 게시판 이용이 정지되며, 해당 유저를 신고한 모든 유저에게 정지 사실을 메일로 발송합니다.
    -   유저가 신고한 모든 내용을 취합하여 마지막에 한꺼번에 게시판 이용 정지를 시키면서 정지 메일을 발송합니다.

다음은 전체 유저 목록이 \["muzi", "frodo", "apeach", "neo"\]이고, k = 2(즉, 2번 이상 신고당하면 이용 정지)인 경우의 예시입니다.

| 유저 ID | 유저가 신고한 ID | 설명 |
| --- | --- | --- |
| "muzi" | "frodo" | "muzi"가 "frodo"를 신고했습니다. |
| "apeach" | "frodo" | "apeach"가 "frodo"를 신고했습니다. |
| "frodo" | "neo" | "frodo"가 "neo"를 신고했습니다. |
| "muzi" | "neo" | "muzi"가 "neo"를 신고했습니다. |
| "apeach" | "muzi" | "apeach"가 "muzi"를 신고했습니다. |

각 유저별로 신고당한 횟수는 다음과 같습니다.

| 유저 ID | 신고당한 횟수 |
| --- | --- |
| "muzi" | 1 |
| "frodo" | 2 |
| "apeach" | 0 |
| "neo" | 2 |

위 예시에서는 2번 이상 신고당한 "frodo"와 "neo"의 게시판 이용이 정지됩니다. 이때, 각 유저별로 신고한 아이디와 정지된 아이디를 정리하면 다음과 같습니다.

| 유저 ID | 유저가 신고한 ID | 정지된 ID |
| --- | --- | --- |
| "muzi" | \["frodo", "neo"\] | \["frodo", "neo"\] |
| "frodo" | \["neo"\] | \["neo"\] |
| "apeach" | \["muzi", "frodo"\] | \["frodo"\] |
| "neo" | 없음 | 없음 |

따라서 "muzi"는 처리 결과 메일을 2회, "frodo"와 "apeach"는 각각 처리 결과 메일을 1회 받게 됩니다.

이용자의 ID가 담긴 문자열 배열 `id_list`, 각 이용자가 신고한 이용자의 ID 정보가 담긴 문자열 배열 `report`, 정지 기준이 되는 신고 횟수 `k`가 매개변수로 주어질 때, 각 유저별로 처리 결과 메일을 받은 횟수를 배열에 담아 return 하도록 solution 함수를 완성해주세요.

___

##### 제한사항

-   2 ≤ `id_list`의 길이 ≤ 1,000
    -   1 ≤ `id_list`의 원소 길이 ≤ 10
    -   `id_list`의 원소는 이용자의 id를 나타내는 문자열이며 알파벳 소문자로만 이루어져 있습니다.
    -   `id_list`에는 같은 아이디가 중복해서 들어있지 않습니다.
-   1 ≤ `report`의 길이 ≤ 200,000
    -   3 ≤ `report`의 원소 길이 ≤ 21
    -   `report`의 원소는 "이용자id 신고한id"형태의 문자열입니다.
    -   예를 들어 "muzi frodo"의 경우 "muzi"가 "frodo"를 신고했다는 의미입니다.
    -   id는 알파벳 소문자로만 이루어져 있습니다.
    -   이용자id와 신고한id는 공백(스페이스)하나로 구분되어 있습니다.
    -   자기 자신을 신고하는 경우는 없습니다.
-   1 ≤ `k` ≤ 200, `k`는 자연수입니다.
-   return 하는 배열은 `id_list`에 담긴 id 순서대로 각 유저가 받은 결과 메일 수를 담으면 됩니다.

___

##### 입출력 예

| id\_list | report | k | result |
| --- | --- | --- | --- |
| `["muzi", "frodo", "apeach", "neo"]` | `["muzi frodo","apeach frodo","frodo neo","muzi neo","apeach muzi"]` | 2 | \[2,1,1,0\] |
| `["con", "ryan"]` | `["ryan con", "ryan con", "ryan con", "ryan con"]` | 3 | \[0,0\] |

___

##### 입출력 예 설명

**입출력 예 #1**

문제의 예시와 같습니다.

**입출력 예 #2**

"ryan"이 "con"을 4번 신고했으나, 주어진 조건에 따라 한 유저가 같은 유저를 여러 번 신고한 경우는 신고 횟수 1회로 처리합니다. 따라서 "con"은 1회 신고당했습니다. 3번 이상 신고당한 이용자는 없으며, "con"과 "ryan"은 결과 메일을 받지 않습니다. 따라서 \[0, 0\]을 return 합니다.

___

##### 제한시간 안내

-   정확성 테스트 : 10초
---
### 코드 작성
```python
def solution(id_list, report, k):
    
    user_dic = {i : 0 for i in id_list}

    report_dic = {}
    for i in set(report):
        user, reports = i.split(' ')
        if reports in report_dic:
            report_dic[reports] += [user]
        else:
            report_dic[reports] = [user]

    reports = []
    for v in report_dic.values():
        if len(v) >= k:
            reports += v

    for name in reports:
        if name in user_dic:
            user_dic[name] += 1

    return list(user_dic.values())
```
---
### 코드 설명

<br/>

```python
user_dic = {i : 0 for i in id_list}
```
- 파이썬 *딕셔너리 표현식* 으로 `user_dic` 변수를 만들어줍니다
<br/>
<br/>

```python
report_dic = {}
for i in set(report):
	user, reports = i.split(' ')
	if reports in report_dic:
		report_dic[reports] += [user]
	else:
		report_dic[reports] = [user]
```
- 문제에서 중복 신고는 포함하지 않는다고 했기 때문에 `set()` 함수를 이용해 `report` 중복을 제거해줍니다
- `report` 에서 받은  `i(이용자ID, 신고자ID)` 를 `split()` 함수로 각각 이용자와 신고자를 나눠줍니다
- 생성한 딕셔너리 변수 `report_dic` 의 `key`값은 `신고자ID`를,  `value`값은  `이용자ID`를 넣어줍니다

<br/>

>아래와 같이 조건을 걸어주는 이유
```python
if reports in report_di
```
<br/>

- 예시
```python
for i in set(report):
	user, reports = i.split(' ')
	report_dic[reports] = [user]

# 출력결과 :  {'neo': ['muzi'], 'frodo': ['muzi'], 'muzi': ['apeach']}
```
- 위 예시 결과를 보면 value값이 두개이상은 들어가지 않는 것을 확인 할 수 있습니다
- 따라서 `reports(신고자ID)`  가 `report_dic` 이미 포함되어 있다면 `user(사용자ID)`를  리스트 형태로 `[]`로 감싸 조건에 맞을때마다 더해서 추가해줍니다
>`append()` 또는 `str` 로 추가하지 않는 이유는
>`append`는 ['muzi', ['frodo']] 와 같이 2차원 형태로 계속 더해지고
>`str` 은 ['muzifrodo'] 와 같이 문자열이  붙어서 출력되는 것을 알 수가 있습니다

<br/>
<br/>

```python
reports = []
    for v in report_dic.values():
        if len(v) >= k:
            reports += v
```
- `이용자ID` 가 들어있는 `report_dic.values()` 를  `for`문 `v`변수에 대입하고, 그 값은 `list`형태이기 때문에 리스트의 길이가 곧 `신고(받은) 횟수`라고 볼 수 있다 
- `len(v)`이 `k(정지기준 횟수)` 같거나 크다면 조건에 맞는 `v(이용자ID)`를 새로운 `reports`리스트에 저장한다
<br/>
<br/>

> **참고**
> 위 코드를 한줄의 리스트표현식으로 나타낼 수 있다
```python
reports = sum([v for v in report_dic.values() if len(v) >= k], [])

# sum()을 이용해 2차원 배열을 1차원으로 나타낼 수 있음 sum([[0],[1]], []) --> [0, 1]
# 코드는 짧아지지만 sum() 함수로 연산이 들어가기 때문에 시간이 좀 더 걸린다
```
<br/>
<br/>

```python
for name in reports:
	if name in user_dic:
		user_dic[name] += 1
```
- `사용자ID` 가 담긴 `reports` 를 `for`문 `name` 변수에 대입하고
- `name(사용자ID)` 이 `user_dic` (사용자ID로 만든 딕셔너리 변수) 포함된다면
- 해당 사용자ID인 `user_dic[name]` 값에 1를 더해줍니다 (포함 될 때마다)
<br/>
<br/>

```python
return list(user_dic.values())
```
- 마지막으로 `user_dic`의 `value` 값을 리스트형태로 리턴 해주면 원하는 결과 값이 나옵니다

---
### 참고 자료